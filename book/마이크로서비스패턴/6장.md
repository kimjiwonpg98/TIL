## 개요

- 영속화된 관리의 문제점
- 이벤트 소싱 패턴
- 이벤트 소싱 프레임 워크
- 큰 틀에서의 이벤트 소싱
- 연관된 문제점 그리고 해결 방법


## 영속화된 관리의 문제점

- **Impedance Mismatch(임피던스 부정합)**
    - 데이터를 객체화시켜 관계형 DB에 Mapping하는데 오는 괴리들이 존재한다.

![query1](https://github.com/user-attachments/assets/38d95274-3d3a-4922-94fe-f139637ab0d4)
![query2](https://github.com/user-attachments/assets/bfb4f21d-023b-41c6-8645-9521d9e2d7d2)

1. 애그리게이트만으로는 히스토리를 다 알 수 없다.
   - 위 데이터만 봐도 몇번 변경되어 count가 변경되었는지 알 수 없다. 
2. 감사 로깅을 구현하기가 번거롭다.
    - 누가 어떤 이유로 변경했는지 알 수 없다.
3. 이벤트 발행 로직이 비즈니스 로직에 추가된다.
   - 주요 이벤트가 아닌 히스토리용 로직이 추가된다.

## 이벤트 소싱 패턴

- 위 문제들에 대한 해결책으로 이벤트 소싱 패턴이 될 수 있다.
- 도메인 이벤트 방식으로 애그리거트를 저장 하고 관리한다.

🟦 장점
- 애그리거트의 이력을 보존한다.
    - 감사 및 통제에 적합하다.
- 이벤트를 확실하게 발행 가능하여 MSA에 적합하다.


### 방법

1. 주문의 생성부터 종료까지 모든것이 이벤트로 저장하고 관리한다.
2. **(⭐️중요)  이벤트마다 어떤 변경을 해야하는지 event_data 필드에 기입하여 관리하게 된다.**
    - 데이터를 가지고 재연이 가능하다.
    - 그러려면 직렬화된 stringify json을 그대로 저장해야한다.


❓마지막 결론은 어떻게 유추할 수 있는가?

1. 모든 이벤트를 순회해서 얻어낸 마지막 상태를 마지막이라고 할 수 있다.
2. 사람이 직접 결과를 도출해나가기엔 어렵다. (쿼리에 어려움)


-> 해결법

> CQRS 패턴을 활용한다.
>  이벤트들을 종합하여 READ 전용으로 레플리카를 운영한다.

## 이벤트 소싱 프레임 워크

![CQRS내용](https://github.com/user-attachments/assets/65431632-a962-4864-ab3b-23a4324851d4)

두가지 메소드로 이벤트 소싱에 대한 개념을 가지고 관리하게 해보자
(이벤트들은 두가지를 반드시 구현해야 한다.)


- process()
  - 커맨드를 입력받아 이벤트를 반환하는
- apply()
  - 이벤트를 전달받아 에그리거트를 업데이트하는

### 예시

- 위 쿼리처럼 count를 변경하는 로직

1. count 변경 요청(커맨드)
   - UpdateCountRequestCommand
2. 변경 요청됨(이벤트가 생성) > process() 메소드의 내용
    - new UpdateCountRequestProposed()
3. 대기중으로 상태 및 값 변경 (apply 메소드가 자동으로 실행)
    - 상태만 바꾸는것이 아니라 다른 값들도 변경

> this.state = “prepending”
>this.count = 10
>this.template_id= 3 … 


## 큰 틀에서의 이벤트 소싱

우리는 이벤트 발행하는 것이 목적이 아닌 데이터의 흐름을 크게 봐야할 필요가 있다.

1. 어떤 프로세스로 인해 커맨드가 발생했다면
2. 우리는 이벤트소싱 패턴으로 이벤트를 발행할 것이고 데이터를 저장
3. 그 다음 행동을 진행한다.
4. 메시지 브로커에게 데이터를 전달해야 한다.

> ⛓️ 메시지 브로커 따위에 후처리를 해줘야 순환의 고리를 연결시킬 수 있음.



## 연관된 문제점 그리고 해결 방법

- 동시에 에그리게이트가 업데이트 될 경우의 문제점
    - 낙관적 Lock 을 시도하여 해결할 수 있다.
      - 이벤트 발행이 꼬이지 않게 하기 위해도 있다.
- 발행된 이벤트를 메시지  브로커에 전달할 때의 문제점
    - 폴링을 전달할 경우
        - 중첩 트랜잭션으로 인해 최종커밋된 이벤트 번호만 처리될 수 있다.
- 발행된 이벤트가 많아 모두 가져와 다시 재연하기 어려운 경우
- 이벤트가 여러번 발행되는 문제

  ![트랜잭션문제](https://github.com/user-attachments/assets/40612146-cd73-4f8c-9d55-1fa7298474ce)

### 해결책

- 테이블에 **published 필드**를 두어 발행된 이벤트를 제외하고 전달할 수 있도록 한다.

- 트랜잭션 로그 테일링으로 해결 -> 모든 트랜잭션 감시하는 방법
- 재연이 어려울 경우는 스냅샷 버전을 만들어 중간부터 다시 재연하도록 할 수 있다.
- 이벤트가 여러번 발행되는 문제는 받는 쪽에서 멱등한 처리를 해주도록 개발이 필요하다.
  - RDBMS를 사용하여 처리된 데이터를 저장하는 백업테이블을 운영

    