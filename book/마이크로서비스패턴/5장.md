## 개요

- 5장 들어가면서
- 비즈니스 로직 패턴 적용
    - 트랜잭션 스크립트 패턴
    - 도메인 모델 패턴
- 도메인 문제점과 규칙
- 이벤트 스토밍
- 도메인 이벤트 패턴 적용
    - 도메인 이벤트 발행

비즈니스 로직이 여러 서비스에 흩어져 있는 아키텍쳐는 복잡한 비즈니스 로직을 개발하기 까다롭다.

<aside>
💡 이유

1. 도메인 모델이 대부분 상호 연관된 클래스가 뒤얽혀있다.
2. 특유의 트랜잭션 관리 제약 조건하에서도 작동되는 비즈니스 로직을 설계해야함
</aside>

책에서 말하는 해결책

비즈니스 로직을 애그리게이트로 구성하는 DDD패턴을 구성하자

<aside>
💡 간단하게 정리한 내용

- 애그리게이트를 사용하면 객체 레퍼런스가 서비스 경계를 넘나들 일이 없다.
- 객체 참조 대신 기본키를 이용해 서로 참조한다.
- 한 트랜잭션에 하나의 애그리게이트만 생성/수정할 수 있다.
- ACID 트랜잭션은 반드시 하나의 서비스 내부에서만 걸리게 된다.
</aside>

## 비즈니스 로직 패턴 적용

- 트랜잭션 스크립트 패턴

동작이 구현된 클래스(service)와 상태(entity)를 보관하는 클래스가 따로 존재한다.

![트랜잭션스크립트](https://github.com/user-attachments/assets/5e83e8e1-ea4d-45f3-9646-00e00c2afc71)


비즈니스 로직에서 모든 작업을 한 트랜잭션 안에서 하게 된다.

🟦 장점

- 구현 방법의 단순함 때문에 구현이 매우 쉽다.
- 얼마나 모듈화를 잘 하느냐에 따라서 높은 효율을 낼 수 있다.

🟥 단점

- 비즈니스 로직이 복잡해질수록 난잡한 코드를 만들게 된다.
- 도메인에 대한 분석/설계 개념이 약하기 때문에 코드의 중복 발생이 쉽다.

- 도메인 모델 패턴

비즈니스 로직을 상태와 동작을 가진 클래스로 구성된 객체 모델로 구성되어있다

![도메인모델](https://github.com/user-attachments/assets/febe5c23-1141-46bc-9ade-472381203f4e)

🟦 장점

- 서비스 메서드가 단순해진다.
    - 영속화 도메인 객체에 위임하기 때문
- 이해하기 쉽다.
- 독립적으로 테스트하기 쉽다.
- 확장하기 쉽다.

🟥 단점

- 객체를 나누는 작업을 잘해야한다.

---

## 주문 객체 설명 전 필요한 정보

### 예시로 들기 위한 주문 서비스의 비즈니스 로직과 어댑터

- 인바운드
    - REST API 어댑터
    - Order Command Handler
        - 커맨드 메시지를 받아 비즈니스 로직을 호출
- 아웃바운드
    - DB 어댑터
        - DB 접근을 위해 호출
    - 도메인 이벤트 발행 어댑터
        - 이벤트를 메시지 브로커에 발행

![주문어그리게이터](https://github.com/user-attachments/assets/d2cc6bcc-5e8b-49a6-a803-799ae56dd957)

### 각 클래스가 도메인 모델에서 수행하는 역할과 클래스 특징

- 엔티티: 영속성 신원을 가진 객체
- 벨류 객체: 여러 값을 모아 놓은 객체 (vo)
- 팩토리: 일반 생성자로 직접 만들기에 복잡한 객체 생성 로직을 구현해둔 객체
- 리포지터리: 엔티티를 저장하는 DB 접근 로직을 캡슐화한 객체
- 서비스: 엔티티, 벨류 객체에 속하지 않은 비즈니스 로직 구현 객체

---

## 도메인 문제점과 규칙

- 전통적인 도메인 모델

![전통적인도메인](https://github.com/user-attachments/assets/85d53bc9-5b45-4cb7-9bbb-589b0c6046dd)

### 문제점?

- 어떤 클래스가 Order라는 비즈니스 객체의 일부인지 분명하지 않다 = 비즈니스 경계가 불분명하다.
- 비즈니스 규칙을 위반할 수 있다.

- 책에서 나온 예시

1. 주문 첫번째 트랜잭션에서 order line item을 조회하여 최소 주문량 확인
2. 최소 주문량 업데이트
3. 최소 주문량이 맞지 않지만 주문 두번째 트랜잭션 발생

### 확인해야 할 내용

1. 불변 값을 찾는다.
    - 주문 품목
    - 최소 주문량(비즈니스 관점에서 규칙으로 삼을 값)
        - 주문 객체에서는 불변값이다.

```kotlin
@Entity
@Table(name = "order")
class Order(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long? = null,
    @Column
    val customerName: String,
    @OneToMany(mappedBy = "order", cascade = [CascadeType.ALL], orphanRemoval = true)
    val orderItems: List<OrderItem>
) {
    fun addItem(item: OrderItem) {
        orderItems.add(item)
    }
}

@Entity
@Table(name = "order_item")
class OrderItem(
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    val id: Long? = null,
    @Column
    val itemName: String,
    @Column
    val price: Int,
    @ManyToOne(fetch = FetchType.LAZY, optional = false)
    @JoinColumn(name = "order_id", referencedColumnName = "id", nullable = false)
    val order: Order
)
```

### 📑 규칙

### 1. 루트 애그리게이트의 메서드만 호출한다.

![루트에그리게이트](https://github.com/user-attachments/assets/8a399562-c658-446b-95c8-fe98e1e0b48e)


>💡 애그리게이트의 경계, 그 루트를 식별하는 것이 필요하다.<br>
루트 메서드만 호출하여 애그리게이트를 업데이트함으로써 자신의 불변값을 강제할 수 있다!


### 2. 반드시 기본키를 사용


>💡 객체 레퍼런스 대신 유니크 값을 사용함으로써 느슨한 결합이 가능해진다.

### **장점**

- 느슨하게 결합되고 경게가 분명해진다 .
- 다른 애그리게이트를 업데이트할 일이 생기지 않는다.
- 다른 서비스의 일부일 때에도 서비스에 걸친 레퍼런스 문제가 없다.

### 3. 하나의 트랜잭션으로 하나의 애그리게이트를 생성/수정해야한다.


>⚠️ 여러 애그리게이트를 생성하거나 수정 시 구현의 어려움이 있다.
<br>
→ 사가 패턴을 이용하여 해결이 가능하다.
<br>
→ 같은 서비스에 있는 애그리게이트라면 같은 트랜잭션에 묶어도 된다.

---

![주문](https://github.com/user-attachments/assets/e4b73556-4406-4054-863b-82d3e9ce2b81)

애그리게이트 기반으로 만들어진 주문 서비스 비즈니스 로직 설계

>🔥 결론적으로 우리는 애그리게이트를 잘 나눠야한다.<br>
가급적 잘게 나누면 좋지만 상황에 따라 비즈니스 로직에 맞춰 유동적으로 설계해야한다.

---

## 이벤트 스토밍

1. 시나리오 기준으로 이벤트 작성
2. 이벤트에 대한 명령어 작성
3. 이벤트의 주체 설정 (actor)
4. aggreagate 정의
5. 이벤트간의 연관관계 연결 (정책)

---

## 도메인 이벤트 발행

> 애그리게이트에 발생한 사건
상태가 전이될 때마다 컨슈머를 위해 이벤트를 발행한다.
>

### 발행의 이유

- 일관성을 유지하기 위함(코레오그래피 시가 → 각자의 서비스에서 구독)
- 레플리카를 둔 서비스가 레플리카를 업데이트하기 위함
- 웹훅을 통해 다음 단계를 진행하도록 알리기 위함
- 사용자에게 직접 보낼 수도 있음 - 알림

### 발행 시 의미를 부여하는 값

- 원시값
- 벨류 객체
    - (특정 값을 알 수 있는 값 ex. orderId)


>**⚠️ 단점**<br>
> 컨슈머의 요건이 바뀌면 이벤트 클래스도 함께 변경되어야한다.<br>
유지보수성이 나빠질 수 있다.
> - 새로운 이벤트로 대체하는 방법?
 



### 주체

![어그리게이트주체](https://github.com/user-attachments/assets/53092d98-8a21-4c72-b825-d10c2fae107e)

기본적으로 도메인 이벤트를 이용한 통신은 비동기 메시징 형태를 취한다.

- 애그리게이트는 이벤트 반환값을 제공
- 서비스에서 이벤트 반환값을 퍼블리쉬한다.

### 확실하게 발행하는 방법

- 서비스가 DB에서 애그리게이트를 업데이트하는 트랜잭션에 이벤트 발행도 같이 진행한다.
    - 이벤트 발행 시 카프카로 예를 들면 카프카도 외부 호출이라고 볼 수 있는데 트랜잭션에 같이 들어가는게 맞을까..?
    - 브로커의 상태가 안좋아서 응답을 받지 못하게 된다면?
  
—> outbox 패턴 사용

1. 서비스 DB 업데이트 시에 outbox에 함께 insert
2. commit 이후 이벤트 발행