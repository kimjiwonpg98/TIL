### 소제목

- 분산 트랜잭션이 요즘 애플리케이션에 잘 어울리지 않는 이유
- 사가 패턴을 적용했을 때 데이터 일관성 유지



### 마이크로서비스 아키텍쳐에서 트랜잭션 관리가 어려운 이유

모놀로식이라면 @Transactional 하나로 데이터 일관성이 보장되지만 여러 서비스로 흩어져 있는 서비스라면
데이터를 각자 접근해서 일관성을 유지해야되는 어려움이 있다.


### 사가 패턴
- 분산 트랜잭션을 대체하기 위해 나온 패턴

> 여러 서비스의 데이터를 업데이트하는 시스템 커맨드마다 사가를 하나씩 정의
> 사가는 일련의 로컬 트랜잭션


##### 분산 트랜잭션과의 차이점

1. ACID 트랜잭션에서 I(격리성)가 사가에는 존재하지 않는다.
2. 로컬 트랜잭션마다 변경분을 커밋해서 보상 트랜잭션을 걸어 롤백해줘야 한다.


#### 주문 서비스로 예시

![주문](https://github.com/user-attachments/assets/8b623b85-9de8-47d2-bc94-78ca1403da15)

순서대로 본인의 상태값으로 처리한다.

1. 서비스는 로컬 트랜잭션이 완료되면 메시지를 발행해 다음 사가 단계를 트리거
2. 메시지를 통해서 느슨한 결합으로 사가가 반드시 완료되도록 보장한다.

> 해결해야할 점들
> 1. 도중에 에러가 발생하면 변경분을 어떻게 롤백할 수 있을까?
> 2. 각 서비스에서 사가에 대해 다음 진행을 하지 못하게 해야되는 상태라면 어떻게 해야될까?
     > 	1. 소비자 서비스에서 소비자가 주문을 할 수 없는 상태라면 어떻게 처리해줘야할까?


어떤 한 단계에서 실패하게 될 경우 앞 단계에서 적용된 부분을 명시적으로 **롤백** 처리를 해주어야 한다.
-> **보상 트랜잭션을 미리 작성해두어야 한다.**


여기서도 두가지로 나눠진다.

- 실패하면 전 단계로 돌려야된다. -> 보상 트랜잭션
- 항상 성공하거나 조회하는 부분이다 -> 재시도 가능 트랜잭션


## 4-2 사가 편성

- 사가는 단계를 편성하는 로직으로 구성된다.
- 기본적으로 시작 시 참여자를 정해 로컬 트랜잭션 실행 -> 완료되면 다음 참여자 호출


### 코레오 그래피

> 의사 결정과 순서화를 참여자에게 맡긴다.
> 사가 참여자는 주로 이벤트 교환 방식으로 통신하게 된다.


- 결국 요약하면 각 서비스가 서로 이벤트를 구독하여 그에 따라서 작업을 진행한다는 뜻이다.


- 성공인 경우

![코레오그래피](https://github.com/user-attachments/assets/5f056cf0-49e6-4e32-ad05-de835d90ca70)

1. 주문 서비스: PENDING 상태 생성 후 이벤트 발행
2. 소비자 서비스: 주문 이벤트 수신 -> 소비자 주문 가능상태인지 확인 -> 소비자 확인 이벤트 발행
3. 주방 서비스: 주문 이벤트 수신 -> 주문 내역 확인 -> PENDING 상태로 생성 -> 티켓 이벤트 발행
4. 회계 서비스: 주문 이벤트 수신 -> 신용카드 승인 PENDING 상태 생성
5. 회계 서비스: 티켓 생성 & 소비자 확인 이벤트 수신 -> 신용카드 과금 처리 -> 승인 이벤트 발행
6. 주방 서비스: 승인 이벤트 수신 -> 티켓 상태 ACCEPT로 변경
7. 주문 서비스: 승인 이벤트 수신 -> 주문 상태 APPROVED로 변경 -> 주문 승인됨 이벤트 발행


- 신용카드 이벤트가 실패한 경우

![실패](https://github.com/user-attachments/assets/4ccb49ef-b276-4d26-9e59-9acc6eb0e546)

1. 주문 서비스: PENDING 상태 생성 후 이벤트 발행
2. 소비자 서비스: 주문 이벤트 수신 -> 소비자 주문 가능상태인지 확인 -> 소비자 확인 이벤트 발행
3. 주방 서비스: 주문 이벤트 수신 -> 주문 내역 확인 -> PENDING 상태로 생성 -> 티켓 이벤트 발행
4. 회계 서비스: 주문 이벤트 수신 -> 신용카드 승인 PENDING 상태 생성
5. 회계 서비스: 티켓 생성 & 소비자 확인 이벤트 수신 -> 신용카드 과금 처리 -> 승인 실패 이벤트 발행
6. 주방 서비스: 승인 이벤트 수신 -> 티켓 상태 REJECTED로 변경
7. 주문 서비스: 승인 이벤트 수신 -> 주문 상태 REJECTED로 변경


##### 🚧🚧🚧고려할 점🚧🚧🚧

1. 참여자가 자신의 DB를 업데이트한 후 트랜잭션의 일부로 이벤트를 발행하도록 해야 한다.
    - 대부분의 경우 트랜잭션의 일부로 외부 트랜잭션을 넣지 않는데 데이터의 일관성을 위해서로 보인다.
2. 참여자는 자신이 수신한 이벤트와 자신의 데이터를 연관 지을 수 있어야 한다.
    - 이벤트 발행자와 참여자가 매핑이 가능한 상관관계 ID를 이벤트에 추가해 연관을 짓는다.
    - 멱등성 처리까지 가능하다.


##### 🟦 장점

- 단순함
    - 비즈니스 객체를 CUD할 때 서비스가 이벤트를 발행
- 느슨한 결합
    - 참여자는 이벤트만 구독할 뿐 서로를 알지 못한다.

##### 🟥 단점

- 여러 구현이 흩어져 있어 이해하기 어렵다.
- 서비스 간 순환 의존성
    - 순환 의존성이 일어날 수 밖에 없다.
        - 예시: 주문 -> 회계 -> 주문
- 결합성이 단단함에 따른 위험성
    - 각자 자신에게 영향을 미치는 이벤트를 모두 구독해야 한다.
    - 서비스에 변경이 일어나면 다른 서비스에도 영향을 끼칠 수 있다.
    - 서비스가 구현된 주기에 맞물려 업데이트가 진행되어야 한다.



### 오케스트레이션

> 편성 로직은 오케스트레이터에 중앙화한다.
> 참여자에게 커맨드 메시지를 보내 수행할 작업들을 지시한다.


- 성공 시

![커맨드](https://github.com/user-attachments/assets/0f30eef7-da68-423c-a9d5-a4ec3eb43acc)

1. 사가 오케스트레이터가 소비자 확인 커맨드를 소비자 서비스에 전송
2. 소비자 서비스는 소비자 확인 메시지를 응답
3. 사가 오케스트레이터는 티켓 생성 커맨드를 주방서비스에 전송
4. 주방 서비스는 티켓 생성 메시지를 응답
5. 사가 오케스트레이터는 신용카드 승인 메시지를 회계서비스에 전송
6. 회계 서비스는 신용카드 승인됨 메시지를 응답
7. 사가 오케스트레이터는 티켓 승인 커맨드를 주방 서비스에 전송
8. 사가 오케스트레이터는 주문 승인 커맨드를 주문서비스에 전송


이 부분도 실패한 부분을 생각해서 설계해야 한다.
상태에 따라 이벤트를 구성하도록 하는 것이 테스트 측면에서 더욱 더 효율적으로 사용할 수 있다.


> 사가 참여자가 로컬 트랜잭션을 완료하는 시점에 트리거되고, 로컬 트랜잭션의 상태와 결과에 따라 상태전이를 어떻게 하고 어떤 액션을 취할지 결정하게 된다.


![상태전이에따른모델](https://github.com/user-attachments/assets/fb07e51f-7640-4862-8acb-56d15a2ff410)


##### 🟦 장점

- 의존 관계 단순화
    - 오케스트레이터가 참여자를 호출하지만 참여자는 호출하지 않는다.
    - 단방향 호출이기 때문에 순환 의존성이 발생하지 않는다.
- 낮은 결합도
    - 각 서비스는 API만 구현할 뿐 사가 참여자가 발행하는 이벤트는 몰라도 된다.
- 관심사를 분리하고 비즈니스 로직을 단순화
    - 도메인 객체는 본인의 역할만 수행하기 때문에 더 단순하게 설계할 수 있다.

##### 🟥 단점

- 오케스트레이터에 많은 중앙화
    - 모든 서비스가 오케스트레이터에 의존하게 된다.
    - 해결 방법: 오케스트레이터는 순서화만 담당하고 비즈니스 로직은 갖고 있지 않도록 한다.



## 비격리 문제 처리

> **격리성**
> 동시에 여러 트랜잭션이 수행할 때 다른 트랜잭션의 영향을 받지 않는 것


사가는 격리성이 빠져 있으며 이것은 2가지의 문제를 야기한다.

1. 한 사가가 실행 중에 접근하는 데이터를 다른 사가가 바꿔치기할 수 있다.
2. 한 사가가 업데이트 전 데이터를 다른 사가가 읽을 수 있어 데이터 일관성이 깨질 수 있다.


#### 비격리 시 비정상 내용

1. 소실된 업데이트
    - 한 사가의 변경분을 다른 사가가 못 읽고 덮어질 수 있다.
2. 더티 읽기
    - 엡데이트를 하지 않은 변경분을 다른 트랜잭션이나 사가가 읽는다.
3. 퍼지/반복 불가능한 읽기
    - 한 사가의 상이한 두 단계가 같은 데이터를 읽어도 결과가 달라진다.




## 비격리 대책

- 기본적으로 PENDING 상태로 변경 후에 업데이트하는 것이 애플리케이션 수준에서 가장 간단한 대책이다.


### 사가의 구조

- 보상 가능 트랜잭션
    - 실패 시 롤백 가능한 트랜잭션
- 피봇 트랜잭션
    - 커밋하게 되면 완료될 때까지 실행해야 하는 트랜잭션
- 재시도 가능 트랜잭션
    - 피봇 트랜잭션 직후의 트랜잭션으로 반드시 성공해야 한다.



### 1. 시맨틱 락

- 보상 가능 트랜잭션이 생성/수정하는 레코드에 무조건 플래그를 세팅하는 대책
- 플래그는 재시도 가능 트랜잭션 (성공 시) 혹은 보상 트랜잭션(실패 시)로 해제된다.
- 하지만 데드락을 관리해야되는 부담이 생긴다.

### 2. 교환적 업데이트

- 어떤 순서로도 실행 가능하도록 설계하여 업데이트 소실이 없도록 한다.
- 롤백을 하게 되면 반대의 명령어를 실행한다.
- 예시: 입금 후 롤백하게 되면 인출로 업데이트

### 3. 비관적 관점

- 더티 읽기로 인한 리스크를 최소화하기 위해 사가 단계의 순서를 재조정한다.
- 더티 읽기로 리스크있는 명령을 가장 마지막에 한다. (재시도 가능 트랜잭션에서 실행)

### 4. 값 다시 읽기

- 소실된 업데이트를 방지하는 대책
- 업데이트 하기 전에 값을 다시 읽어 변경되었는지 확인한다.
    - 변경되었다면 중단하고 나중에 재시작한다.


### 5. 버전 파일

- 레코드에 수행한 작업을 모두 기록한다.
- 기록한 내용을 토대로 서비스가 처리하게 된다.


### 6. by value

- 위험성을 기준으로 매커니즘을 선택한다.
    - 위험성이 낮은 작업: 사가
    - 위험성이 높은 작업: 분산 트랜잭션

