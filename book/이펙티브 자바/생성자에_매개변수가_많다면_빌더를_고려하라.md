# 생성자에 매개변수가 많다면 빌더를 고려하라

안좋은 예시들

1. 점층적 생성자 패턴
```java
public class User {
    private final String name;
    private final String sex;
    private final String phoneNumber;
    private final String address;
    
    
    public User(String name, String sex) {
        this(name, sex);
    }
    
    public User(String name, String sex, String phoneNumber, String address) {
        this(name, sex, phoneNumber, address);
    }
}
```
매개변수를 받는 개수가 달라질때마다 새롭게 생성자를 늘려가는 방식이다.   
당연하게도 코드가 장황해지고 순서가 바껴도 컴파일러는 알 수 없으며 런타임에서 에러가 난다.

2. 자바빈즈패턴

```java
public class User {
    private final String name = "기본값";
    private final String sex;
    private final String phoneNumber;
    private final String address;

    public User() {
    }

    public void setName() {
        String name = val;
    }
    // 나머지도 다 set으로
}
```

매개변수 없는 생성자로 객체를 만든 후에 세터 메서드를 호출해서 매개변수의 값을 설정한다.   
이것도 객체를 하나 만들 떄 여러 메서드를 호출해야되고 완전히 생성되기 전까지 (set이 다 안끝남) 일관성이 무너진 상태로 유지된다


### 빌더 패턴

```java
public class User {
    private final String name = "기본값";
    private final String sex;
    private final String phoneNumber;
    private final String address;

    public static class Builder {
        private final String name; // 필수 매개변수
        private final String sex;

        private final String phoneNumber = "01012345678";  // 선택 매개변수
        private final String address = "seoul";
        
        public Builder(String name, String sex) {
            this.name = name;
            this.sex = sex;
        }
    }
}
```

lombok의 Builder를 사용하면 되지만 이런 식으로 할 수도 있다.  
어찌됐든 Builder를 생성하는 비용도 있지만 적어도 순서때문에 골치아플 일은 없고   
매개변수 4개 이상부터는 쓸만하다.


또한 하위 클래스에서는 형변환을 하지 않고도 메서드를 연계할 수 있다.

```java
public class Student extends User {
    public enum Grade { MIDDLE, HIGH }
    private final Grade grade;
    
    // Student의 빌더는 grade도 쓸 수 있다.
    public static class Builder extends User.Builder {
        private final Grade grade;
        
        @Override public Student build() {
            return new Student(this);
        }
        
        // 부모 클래스에 정의된 메서드를 호출해도 반환되는 객체는 자식이여야함
        @Override protected Builder self() { return this; }
    }
}

Student s = new Student.Builder(name, sex)
        .address("Seoul") // User.Builder의 메서드
        .grade(Grade.HIGH) // Student.Builder의 메서드 (self() 덕분에 체이닝 가능)
        .build();          // Student 객체 반환 (형변환 불필요)
```


