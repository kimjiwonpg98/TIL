> 많은 양의 트래픽을 감당하고 처리하는 대용량의 웹 서버에서 꼭 조절해야하는 timewait와 keepalive의 상관관계에 대해서 알아보겠다!




## 1. 🔗🔨 timewait 소켓

> 먼저 연결을 끊는 쪽에서 생기는 소켓 상태
리눅스에서 60초 타이머 동작 이후 커널로 다시 반환


여기서 중요한 점은 **먼저 연락을 끊는다**라는 것입니다.
상대방이 더 보낼 데이터가 있는지 상관 없이, 한 번 통신이 끝나면 연락을 끊어버립니다. 


> **<font color="ef6f53">더 보낼 데이터가 있는 상대는 TCP 연결을 처음부터 다시 해야합니다. 이 과정에서 TCP 3-way handshake가 한 번 더 발생합니다!</font>**

결론적으로 timewait 상태가 많다는 것은 서비스의 응답 속도가 느려질 수 있다는 것을 의미합니다.


## 2. 🔗 keepalive

> 먼저 연결을 끊지 않고 클라이언트의 연결 요청을 처리한 후 일정 시간을 대기합니다.


### Nginx에서의 설정

```js
upstream backend {
    ...
    keepalive 100; // keepalive 갯수
    keepalive_timeout 30; // keeplive의 생존 시간 (초)
}
```

여러 번의 GET 요청 등이 있을 때 클라이언트는 한 번만 TCP 세션을 연결하고 **생존 시간동안 동일한 세션으로 데이터를 주고 받을 수 있습니다.**

결론적으로 불필요한 timewait 소켓이 생성되지 않게 막아줍니다. => 더 빠른 통신 가능! 😎


### keepalive의 단점

설계되지 않은 keepalive의 사용은 처리 가능한 웹서버의 스레드 부족 현상을 일으킬 수 있습니다.

예를 들어 2000개의 워커를 사용하는 웹서버에 2000개의 세션이 keepalive 상태라면 2001번째 세션은 처리할 워커가 없기 때문에 서비스의 전체적인 응답 속도 저하를 가져 옵니다.



## 3. 👨‍💻 결론

자신의 웹서버에 들어오는 request양을 잘 파악하여 timewait 소켓과 keepalive를 조절해야합니다.




-------------


### 참고

https://brunch.co.kr/@alden/2#comment
