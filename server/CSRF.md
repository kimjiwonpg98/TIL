# 👨‍💻 Cross Server Request Forgery (사이트 간의 요청 위조)

<br>

## 📃 정의
--------------------------------

사이트 간의 요청(POST, PUT, PATCH, DELETE 등)에서 **위조 요청**을 보내 특정 페이지의 보안을 취약하게 하거나
**데이터를 수정 혹은 삭제**하는 보안 공격 방법

<br>
<br>

## 🔓 해커가 공격하는 과정
----- 

1. 공격자가 URL링크 안에 위조 요청을 숨긴채로 사용자에게 보낸다.

2. 사용자가 URL링크를 열게 되면 위조 요청이 실행된다.

3. 위조 요청이 ID, PW를 변경하는거라면 사용자의 정보를 얻을 수 있게 된다.

![CSRF1](https://user-images.githubusercontent.com/75289370/118137712-7cd25d80-b440-11eb-9a03-277403230149.PNG)

<br>

## 🔑 공격하기 위해 필요한 조건
--------------------------------

1. 공격자가 원하는 정보를 수정하거나 얻기 위해 쿠키에 데이터가 있어야 한다.

2. 공격자가 보낸 요청을 받기 위해 사용자에게 보낸 
     URI를 사용자가 클릭해야 한다.

3. 웹 브라우저가 신뢰하는 사이트에 위조 요청을 보내야 한다.

4. 정보를 수정하거나 얻으려는 페이지의 요청 URL의 패턴을 분석해야 한다.

<br>
<br>

## ⛔ 방어 기법
--------------------------------

### 1. Referrer 헤더를 이용하는 방법

🔮 Referrer: 현재 요청된 페이지의 링크와 이전의 웹 페이지 주소를 포함하는 헤더

Referrer를 보고 웹 브라우저에서 **도메인이 일치**하는지 확인하는 방법 <br>
가장 보편적으로 사용하면서 CSRF공격의 대부분을 막을 수 있다.

<br>

### 2. CSRF Token 사용

랜덤한 수를 사용자의 세션에 토큰으로 저장하여 사용자의 모든 요청에 대해 서버단에서 계속 검증

>간단한 코드
```js
// 로그인시, 또는 작업화면 요청시 CSRF 토큰을 생성하여 세션에 저장해줍니다. 
session.setAttribute("CSRF_TOKEN",UUID.randomUUID().toString());

// 요청 페이지에 CSRF 토큰을 셋팅하여 전송한다 
<input type="hidden" name="_csrf" value="${CSRF_TOKEN}" />
 
// 요청 받을 때마다 요청 파라미터에 전달되는 토큰 값과 세션에 저장된 토큰과 비교
```
이런 식으로 세션안에 토큰을 넣고 토큰 값과 세션에 있는 토큰 값을 서버에서 비교

<br>


### 3. CAPTCHA 사용

사용자가 변경을 의도하는 경우에만 변경을 시켜 주기 위해서
인증코드가 맞다면 변경을 해주는 역할을 수행


<br>

### 4. Double Submit Cookie 

웹 브라우저의 **SOP 정책**으로 인해 <br>
자바스크립트에서 **타 도메인의 쿠키 값을 확인 혹은 수정하지 못한다**는 점을 <br>
이용한 방어 기법

요청시에 난수를 생성한 후
- 요청 파라미터 혹은 헤더
- 쿠키
이 두개에 저장한다.

서버에서는 두 값이 일치하는지 검사








 