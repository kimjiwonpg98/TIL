# 코루틴 취소처리

## 개념
코루틴 취소는 실행 중인 코루틴을 중단시키는 메커니즘입니다. 메모리 누수 방지와 불필요한 작업 중단에 사용됩니다.

## 취소 방법

### 1. Job.cancel()
```kotlin
val job = launch {
    repeat(1000) { i ->
        println("작업 $i")
        delay(500)
    }
}

delay(2000)
job.cancel()  // 코루틴 취소
job.join()    // 취소 완료까지 대기
```

- cancel 함수의 문제
  - 코루틴을 곧바로 취소하지 않고 **취소 확인용 플래그**를 취소 요청됨 으로 바꾸는 역할만 한다.
  - 이후에 취소 확인용 플래그가 확인되는 시점에 코루틴이 취소되어 없다면 계속 유지된다.

#### 문제 예시
```kotlin
val job = launch {
    repeat(1000) { i ->
        Thread.sleep(1000)  // 취소 확인 안함
        println("작업 $i")
    }
}

job.cancel()  // 취소 요청했지만 계속 실행됨
executeAfterJobCancelled() // 동작함
```

#### 해결 방법
```kotlin
// 1. delay 사용 (취소 확인 포함)
val job = launch {
    repeat(1000) { i ->
        delay(1000)  // 취소 확인 자동 수행
        println("작업 $i")
    }
}

// 2. isActive 체크
val job = launch {
    repeat(1000) { i ->
        if (!isActive) return@launch  // 취소 확인
        Thread.sleep(1000)
        println("작업 $i")
    }
}

// 3. ensureActive() 사용
val job = launch {
    repeat(1000) { i ->
        ensureActive()  // 취소시 예외 발생
        Thread.sleep(1000)
        println("작업 $i")
    }
}
```

- 취소된 후에 실행되야 하는 코루틴이 있다면?
  - cancelAndJoin 함수를 사용
  - 취소 요청 후 취소가 완료될 때까지 호출 코루틴을 일시 중단

```kotlin
val job = launch {
    repeat(1000) { i ->
        Thread.sleep(1000)  // 취소 확인 안함
        println("작업 $i")
    }
}

job.cancelAndJoin()  // 취소가 될 때까지 코루틴 일시 중단
executeAfterJobCancelled() // 동작함
```
이래도 println("작업") 이 실행된다. = 일시 중단 시점이 없다



### 2. withTimeout
```kotlin
try {
    withTimeout(3000) {  // 3초 제한
        repeat(10) {
            delay(1000)
            println("작업 진행중...")
        }
    }
} catch (e: TimeoutCancellationException) {
    println("시간 초과로 취소됨")
}
```

### 3. withTimeoutOrNull
```kotlin
val result = withTimeoutOrNull(2000) {
    delay(3000)
    "완료"
}
println(result ?: "취소됨")  // null 반환시 취소된 것
```

## 취소 확인 방법

### 1. isActive 체크
```kotlin
val job = launch {
    while (isActive) {  // 취소 상태 확인
        // 작업 수행
        Thread.sleep(100)  // delay 대신 사용시 취소 불가
    }
}
```

### 2. ensureActive()
```kotlin
val job = launch {
    repeat(1000) { i ->
        ensureActive()  // 취소되었으면 CancellationException 발생
        // 무거운 작업
        Thread.sleep(100)
    }
}
```

### 3. yield() 사용
```kotlin
val job = launch {
    repeat(1000) { i ->
        yield()  // 취소 체크 + 다른 코루틴에게 실행 양보
        // 작업 수행
    }
}
```

## 취소 예외 처리

### CancellationException
```kotlin
val job = launch {
    try {
        delay(5000)
    } catch (e: CancellationException) {
        println("코루틴이 취소됨: ${e.message}")
        // 정리 작업
    } finally {
        println("리소스 정리")
    }
}

delay(1000)
job.cancel("사용자 요청으로 취소")
```

### NonCancellable 컨텍스트
```kotlin
val job = launch {
    try {
        delay(5000)
    } finally {
        withContext(NonCancellable) {
            // 취소되어도 실행되는 정리 작업
            delay(1000)
            println("정리 완료")
        }
    }
}
```

## 부모-자식 관계 취소

### 부모 취소시 자식도 취소
```kotlin
val parentJob = launch {
    val child1 = launch { 
        delay(10000)
        println("자식1 완료")
    }
    val child2 = launch { 
        delay(10000) 
        println("자식2 완료")
    }
}

delay(2000)
parentJob.cancel()  // 모든 자식 코루틴도 취소됨
```

### 자식 실패시 부모도 취소
```kotlin
val job = launch {
    launch {
        throw Exception("자식에서 예외 발생")
    }
    // 부모도 취소됨
}
```

## 주의사항
- `Thread.sleep()` 사용시 취소 불가 (delay 사용 권장)
- CPU 집약적 작업에서는 주기적으로 `isActive` 체크 필요
- `CancellationException`은 정상적인 취소이므로 다시 throw 해야 함
- finally 블록에서 suspend 함수 사용시 `NonCancellable` 컨텍스트 필요